package tinkoffGO_summer2023

//В вымышленной стране прошел очень важный экзамен (ОВЖ).
//Именно по результатам ОВЖ определяется, насколько хорошо каждый город организовал образовательный процесс.
//Качество организации образовательного процесса в столице этой страны
//вычисляется как медианный балл учеников, писавших ОВЖ в данном городе
//(по счастливой случайности количество учеников, писавших ОВЖ, является нечетным числом).
//Например, если ученики набрали баллы[12,6,23], то качество организации образовательного процесса будет равняться 12.
//Эксперты готовы поставить i-му ученику целое число баллов от l_i включительно.
//Они бы хотели выставить всем максимально возможные баллы, но боятся, что если они суммарно выставят более чем s баллов,
//то министерство образования страны может заподозрить их в необъективной оценке работ и уволить.
//Гарантируется, что эксперты могут выставить баллы, чтобы их не уволили (т.е. сумма всех l_i не превосходит числа s).
//Вы являетесь очень важным человеком, поэтому эксперты, проверяющие работы, обратились за помощью к вам.
//Определите, каким образом необходимо выставить баллы, чтобы максимизировать медианный балл,
//не допустив при этом никаких нарушений. Требуется сообщить экспертам только сам максимально возможный медианный балл.
//Формат входных данных
//Первая строка содержит числа n и s (1≤n≤2⋅10^5, 1≤s≤10^9) —
//количество учеников в столице и ограничение сверху на суммарный балл учеников.
//Гарантируется, что число n является нечетным.
//Следующие n строк содержат числа l_i и r_i (1≤l_i≤r_i≤10^9) — минимальный и максимальный баллы для i-го ученика.
//Формат выходных данных
//Выведите одно число — максимальный медианный балл, которого можно добиться, не нарушив никаких ограничений.

//func Six() {
//	var (
//		count int
//		limit int
//		max   []int
//		res   int
//	)
//
//	fmt.Scan(&count, &limit)
//	resSl := make([]int, count)
//	for i := 0; i < count; i++ {
//		var temp1, temp2 int
//		fmt.Scan(&temp1, &temp2)
//		res += temp1
//		resSl[i] = temp1
//		max = append(max, temp2)
//	}
//	ost := limit - res
//	sort.Ints(resSl)
//	con := ost / (count/2 + 1)
//	for i := count/2 + 1; i < count; i++ {
//		if resSl[i] < max[i] && resSl[i]+con < max[i] {
//			resSl[i] += con
//		}
//	}
//	fmt.Println(resSl[count/2+1])
//}
